Lab 4 Code Walk
---------------

Walk thru 1: simpledb.Parser.main() and simpledb.Parser.start()

	simpledb.Parser.main() is the entry point for the SimpleDB system. It calls simpledb.Parser.start(). The latter performs three main actions:
		1) It populates the SimpleDB catalog from the catalog text file provided by the user as argument (Database.getCatalog().loadSchema(argv[0]);).
		2) For each table defined in the system catalog, it computes statistics over the data in the table by calling: TableStats.computeStatistics(), which then does: TableStats s = new TableStats(tableid, IOCOSTPERPAGE);
		3) It processes the statements submitted by the user (processNextStatement(new ByteArrayInputStream(statementBytes));)

Walk thru 2: simpledb.Parser.processNextStatement()

	This method takes in the user input and attempts to parse it as SQL, using
	the Zql parsing library.  This method handles bad user input, as well as valid SQL statements include INSERT, DELETE, and SELECT statements.  

	We focus on the SELECT statement which is handled by 
		handleQueryStatement((ZQuery)s)
	This returns a Query object, which is then executed by calling
		query.execute();

Walk thru 3: simpledb.Parser.handleQueryStatement()

	This method takes in a Zquery and a TransactionId and return a Query (a wrapper for DbIterator).
	The logical plan is generated by calling the simdledb.Parser.pareseQueryLogialPlan method.
	The physical plan is generated from the logical plan by calling LogicalPlan.physicalPlan()
	These are then included in the new query before it is returned.

Walk thru 4: simpledb.Parser.parseQueryLogicalPlan()

	First a LogicalPlan object is created and every table in the FROM clause will be added to a list to scan.

	Next the WHERE clause is parsed. This is achieved by calling the parsingExpression method in the same class. 
	Join and Filter nodes are created according to the information contained in the clause.

	Next the GROUP BY field is picked out. Only one aggreagate field is supported.

	Finally, the SELECT fields are used to located the maching fields and return the appropriate result.
	For the aggregate fields, the name and aggregate function provided in the SELECT section will allow SimpleDb to collect the appropriate information.

	Note: this method is rather long and complex.  Your walk thru should focus
	on the high-level ideas.  Specifically, explain how SQL query is processed to construct the LogicalPlan.  
 
Walk thru 5: simpledb.LogicalPlan.physicalPlan()

	Your walk thru should explain how these data structures are used:
		- equivMap
		- filterSelectivities
		- statsMap
		- subplanMap

	This method converts the logical plan to a physical plan in the form of a DbIterator.
	The role of each of the above data structures:
		+equivMap: map tables to each other after the join operation in order build the relational algebrea tree. Map joined table to a single table name to keepp track of the operations performed.
		+filterSelectivities: map a table name with the selectivity of its associated filters.
		+statsMap: map a table name with the statistics about the table.
		+subplanMap: map a table name with an operation being applied to it.

Walk thru 6: simpledb.JoinOptimizer.orderJoins()

	Reorder the list of LogicalJoinNodes stored in the class to generate an efficient plan to perform the joins.
	The order is decided based on the statistics of each table and the selectivity of the filter applied on each.

Walk thru 7: JoinOptimizer.computeCostAndCardOfSubplan()

	This method computes the cost and cardinality of adding the join operation joinToRemove to joinSet.
	The cost of joining the all subsets of size(joinSet)-1 is stored in PlanCache pc.
	It returns a CostCard object that provide the specific cost and cardinality as well as the plan to achieve these result.

Walk thru 8: JoinOptimizer.estimateJoinCost()

	Calculate the estimated cost of performing a join operation based on the estimated costs and cardinalities of the query provided.
	It is estimated using the following formula: joincost(t1 join t2) = scancost(t1) + ntups(t1) x scancost(t2) 
	

Walk thru 9: JoinOptimizer.estimateJoinCardinality()

	Caculate the estimated cardinality of a join operation based on the estimated costs and cardinalities of the query provided.
	It is estimated using the formula: ntups(t1 join t2) = ntups(t1) * ntups(t2) / max ( V(A, t1), V(B, t2) ) where V(A, t1) is the number of distinct values of attribute A in t1.

Walk thru 10 query.execute()
	
	Note: This is called inside simpledb.Parser.processNextStatement().  Refer back to Walk thru 2.

	After a query is parsed into the Parser, it is handle according to its type and then executed if it can be parsed.
	Otherwise, an exception is thrown.
	The method itself print out the result of the operation by traversing (and executing) relational algebra tree and print out the output.

